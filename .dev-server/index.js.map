{
  "version": 3,
  "sources": ["../src/cli-tools/logger.ts", "../src/cli-tools/terminal.ts", "../src/cli-tools/spinner.ts", "../src/cli-tools/commandSchema/commandSchema.ts", "../src/cli-tools/commandSchema/parseSchema.ts", "../src/cli-tools/commandSchema/helpSchema.ts", "../src/cli-tools/commandSchema/validate.ts", "../src/cli-tools/commandSchema/index.ts", "../src/utils/utils.ts", "../src/commands/test-command.ts", "../src/index.ts", "../src/sites/yts.ts"],
  "sourcesContent": ["import chalk, { type ColorName } from 'chalk';\n\n/**\n * - Prints a styled message to the console.\n *\n * @example\n *   Log('Hello World!'); // Prints: | LOG | Hello World! |\n *   Log.info('Hello World!'); // Prints: | INFO | Hello World! |\n *   Log.error('Hello World!'); // Prints: | ERROR | Hello World! |\n *   Log.warn('Hello World!'); // Prints: | WARNING | Hello World! |\n */\nexport function Log(...messages: unknown[]) {\n  console.log(formatLogTitle('LOG', 'white'), ...messages);\n}\n\nLog.warn = (...messages: string[]) => {\n  const { newlines, afterNewline } = getNewlines(messages);\n  console.log(newlines + formatLogTitle('WARNING', 'yellow'), chalk.yellow(afterNewline));\n};\n\nLog.success = (...messages: string[]) => {\n  const { newlines, afterNewline } = getNewlines(messages);\n  console.log(newlines + formatLogTitle('SUCCESS', 'green'), chalk.green(afterNewline));\n};\n\nLog.error = (...messages: string[]) => {\n  const { newlines, afterNewline } = getNewlines(messages);\n  console.log(newlines + formatLogTitle('ERROR', 'red'), chalk.red(afterNewline));\n};\n\nLog.info = (...messages: string[]) => {\n  const { newlines, afterNewline } = getNewlines(messages);\n  console.log(newlines + formatLogTitle('INFO', 'blue'), chalk.blue(afterNewline));\n};\n\nfunction formatLogTitle(title: string, color: ColorName) {\n  title = ' '.repeat(3) + title.padEnd(10);\n  return chalk[color]('|') + chalk[color].bold.inverse(title) + chalk[color]('|');\n}\n\nfunction getNewlines(messages: string[]) {\n  const message = messages.join(' ');\n  const newlineRegex = /^(\\s*[\\n\\r]+)/;\n  const match = message.match(newlineRegex);\n\n  if (match) {\n    const newlines = match[0];\n    const afterNewline = message.substring(match[0].length);\n    return { newlines, afterNewline };\n  }\n\n  return { newlines: '', afterNewline: message };\n}\n", "import { exec, spawn } from 'child_process';\r\nimport { realpathSync } from 'fs';\r\nimport path from 'path';\r\nimport { promisify } from 'util';\r\n\r\nimport type { ExecOptions, SpawnOptions } from 'child_process';\r\n\r\n/**\r\n * - Spawns a shell then executes the command within that shell.\r\n *\r\n * @example\r\n *   const stdout = await $`node -v`;\r\n *   // you can pass options, just make sure to pass it at the last:\r\n *   const stdout = await $`node -v ${{ cwd: 'project' }}`;\r\n */\r\nexport async function $(strings: TemplateStringsArray, ...values: [] | string[] | [...string[], ExecOptions]): Promise<string> {\r\n  const command = strings.reduce((acc, str, i) => acc + str + (typeof values[i] === 'string' ? values[i] : ''), '');\r\n  const options = (typeof values[values.length - 1] === 'object' ? values.pop() : {}) as ExecOptions;\r\n  return (await promisify(exec)(command, options)).stdout.trim();\r\n}\r\n\r\nexport function executeCommand(command: string, args: readonly string[], options: SpawnOptions) {\r\n  return new Promise((resolve, reject) => {\r\n    const childProcess = spawn(command, args, options);\r\n    const output = '';\r\n\r\n    childProcess.on('close', code => {\r\n      if (code === 0) {\r\n        resolve(output);\r\n        return;\r\n      }\r\n\r\n      reject(new Error(`Command exited with code ${code}`));\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * - Execute a command in the shell, and pass the stdout to the parent process.\r\n *\r\n * @example\r\n *   await cmdPassThrough`node -v`;\r\n *   // you can pass options, just make sure to pass it at the last:\r\n *   await cmdPassThrough`node -v ${{ cwd: 'project' }}`;\r\n */\r\nexport function cmdPassThrough(strings: TemplateStringsArray, ...values: [] | string[] | [...string[], SpawnOptions]) {\r\n  const strArr = strings\r\n    .reduce((acc, str, i) => acc + str + (typeof values[i] === 'string' ? values[i] : ''), '')\r\n    .split(' ')\r\n    .filter(Boolean);\r\n  const command = strArr[0];\r\n  const args = strArr.slice(1);\r\n  const options = (typeof values[values.length - 1] === 'object' ? values.pop() : {}) as SpawnOptions;\r\n  return executeCommand(command, args, { stdio: 'inherit', shell: true, ...options });\r\n}\r\n\r\nexport function sleep(ms: number) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/** Removes ANSI escape codes for terminal colors from a given input string. */\r\nexport function cleanTerminalColors(inputString: string) {\r\n  // eslint-disable-next-line no-control-regex\r\n  const colorRegex = /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;\r\n  const cleanedString = inputString.replace(colorRegex, '');\r\n  return cleanedString;\r\n}\r\n\r\n/**\r\n * - To test your cli arguments when using hot reload in development mode.\r\n * - Make sure to remove the test argument before using it in production.\r\n *\r\n * @example\r\n *   testCliArgsInput('command --test-arg=\"test\"');\r\n */\r\nexport function testCliArgsInput(input: string) {\r\n  const regex = /\\s(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/;\r\n  const result = input\r\n    .split(regex)\r\n    .map(item => item.replace(/\"/g, ''))\r\n    .filter(Boolean);\r\n  process.argv.push(...result);\r\n}\r\n\r\nexport const CONSTANTS = {\r\n  /** - Get the current platform */\r\n  platform: process.platform,\r\n  isWindows: process.platform === 'win32',\r\n  isMac: process.platform === 'darwin',\r\n  isLinux: process.platform === 'linux',\r\n  /** - Check if we are in development mode */\r\n  isDev: process.env.NODE_ENV === 'development',\r\n  /** - Get the project root directory full path */\r\n  get projectRoot() {\r\n    const scriptPath = realpathSync(process.argv[1]);\r\n    const suffixesToRemove = ['.dev-server', 'dist'];\r\n    const pattern = new RegExp(`(${suffixesToRemove.join('|')})$`);\r\n    return path.dirname(scriptPath).replace(pattern, '');\r\n  },\r\n} as const;\r\n", "import { Log } from '@cli/logger.js';\nimport { sleep } from '@cli/terminal.js';\nimport chalk from 'chalk';\n\n// ? \uD83D\uDC81 See `https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json` for more spinners.\nconst frames = ['\u280B', '\u2819', '\u2839', '\u2838', '\u283C', '\u2834', '\u2826', '\u2827', '\u2807', '\u280F'];\n/**\n * \u26A0\uFE0F if the terminal's window is resized while the spinner is running, weird behavior may occur.\n *\n * @example\n *   const loading = progress('Loading...'); // start the spinner\n *   loading.start('Downloading...'); // update the message without stopping the spinner\n *   loading.error('Error...'); // stop the spinner and print an styled message\n *   loading.success('Success!'); // stop the spinner and print an styled message\n *   loading.log('Log...'); // stop the spinner and print a message without styling\n *   loading.stop(); // stop the spinner\n */\nexport function spinner(message: string, autoStopTimer = 0) {\n  let rowNumber: number, // row number\n    id: NodeJS.Timeout | null; // to save the interval id\n\n  async function start(startMessage = message, timer = autoStopTimer) {\n    if (id) clearInterval(id);\n    process.stdin.setEncoding('utf8'); // set encoding to utf8\n    process.stdin.setRawMode(true); // disable buffering\n\n    process.stdin.once('readable', () => {\n      const buf = process.stdin.read(), // read the buffer\n        str = JSON.stringify(buf), // \"\\u001b[9;1R\n        xy = /\\[(.*)/g.exec(str)?.[0].replace(/\\[|R\"/g, '').split(';'), // get x and y coordinates\n        pos = { rows: +(xy?.[0] || '0'), cols: +(xy?.[1] || '0') }; // get cursor position\n\n      process.stdin.setRawMode(false); // disable raw mode\n\n      rowNumber = pos.rows - (id ? 1 : 0); // set row number\n      id = null;\n      // animate the spinner with a message.\n      let i = 0;\n      id = setInterval(() => {\n        process.stdout.cursorTo(0, rowNumber); // \u2934\uFE0F move cursor to the start of the line.\n        process.stdout.clearLine(0); // \uD83E\uDDF9 clear first progress line.\n        const spinner = chalk.cyan(frames[i++ % frames.length]); // get next frame\n        const loadingMessage = chalk.yellow(startMessage); // \u2709\uFE0F user message.\n        process.stdout.write(`${spinner}  ${loadingMessage}`); // \uD83D\uDDA8\uFE0F print spinner to the console.\n      }, 80);\n    });\n\n    process.stdin.resume();\n    process.stdout.write('\\u001b[6n'); // will report the cursor position to the application\n\n    // \uD83D\uDD50 wait for a certain amount of time before stopping the spinner.\n    if (timer) {\n      await sleep(timer);\n      stop();\n    }\n  }\n\n  function stop() {\n    if (!id) return;\n    clearInterval(id); // \uD83D\uDED1 stop the animation.\n    id = null;\n    process.stdout.cursorTo(0, rowNumber); // \u2934\uFE0F move cursor to the start of the line.\n    process.stdout.clearLine(0); // \uD83E\uDDF9 clear the progress line.\n  }\n\n  start(); // \uD83D\uDE80 start the spinner.\n\n  // \u21AA\uFE0F return a function to stop the spinner with a message.\n  return {\n    /** \uD83D\uDE80 start the spinner. this will stop the previous one. */\n    start,\n    /** \uD83D\uDED1 stop the animation and clear it. */\n    stop,\n    /** \u2705 stop with a success styled message. */\n    success(endMessage: string) {\n      stop();\n      Log.success(endMessage, '\\n'); // \uD83D\uDDA8\uFE0F print end message to the console.\n    },\n    /** \u26D4 stop with an error styled message. */\n    error(endMessage: string) {\n      stop();\n      Log.error(endMessage, '\\n'); // \uD83D\uDDA8\uFE0F print end message to the console.\n    },\n    /** Stop with a none styled message. */\n    log(logMessage: string) {\n      stop();\n      process.stdout.write(logMessage); // \uD83D\uDDA8\uFE0F print end message to the console.\n    },\n  };\n}\n", "import { z } from 'zod';\nimport { NO_COMMAND } from './parseSchema.js';\n\nimport type { AllowedOptionTypes, CommandSchema, SchemaToZodUnion, ZodArray } from './types.js';\n\nexport function createCommandSchema<const T extends CommandSchema<A>, A extends ZodArray>(command: T & CommandSchema<A>): T {\n  return command;\n}\n\nexport function schemaIntoZodUnion<T extends CommandSchema[]>(schema: T) {\n  type Results = z.ZodObject<\n    { command: z.ZodLiteral<string> | z.ZodOptional<z.ZodUndefined>; args: ZodArray } & {\n      [k: string]: z.ZodTypeAny;\n    },\n    'strict'\n  >;\n  type ResultsTuple = [Results, Results, ...Results[]];\n\n  const results: Results[] = [];\n\n  for (let i = 0; i < schema.length; i++) {\n    const cmd = schema[i];\n    const options: Record<string, AllowedOptionTypes> = {};\n\n    if (cmd.options) {\n      for (let j = 0; j < cmd.options.length; j++) {\n        const option = cmd.options[j];\n        options[option.name] = option.type;\n      }\n    }\n\n    // add global options\n    if (cmd.command === NO_COMMAND) {\n      results.push(z.object({ command: z.literal(undefined!), args: cmd.argsType ?? z.string().array(), ...options }).strict());\n      continue;\n    }\n\n    const zObject = z.object({ command: z.literal(cmd.command!), args: cmd.argsType ?? z.string().array(), ...options }).strict();\n    results.push(zObject);\n  }\n\n  const resultsTuple = results as unknown as ResultsTuple;\n\n  return z.discriminatedUnion('command', resultsTuple) as SchemaToZodUnion<T>;\n}\n", "import { z } from 'zod';\n\nimport { Log } from '@cli/logger.js';\nimport { CONSTANTS } from '@cli/terminal.js';\nimport { schemaIntoZodUnion } from './commandSchema.js';\nimport { commandsSchemaToHelpSchema, printHelpFromSchema } from './helpSchema.js';\nimport { validateDevInput } from './validate.js';\n\nimport type { CommandSchema, ParseOptions, ParseReturnType, ZodArray } from './types.js';\n\nexport const NO_COMMAND = 'noCommandIsProvided';\n\nfunction parseArguments(schema: CommandSchema[]) {\n  const toBoolean = (str: string) => (/^--.+=\\bfalse\\b/.test(str) ? false : /^-\\w$|^--[^=]+$/.test(str) ? true : null);\n  const toNumber = (str: string) => (/--.+=[-+]?(\\d*\\.)?\\d+$/.test(str) ? +str.replace(/^--.+=/, '') : null);\n  const toString = (str: string) => (/^--.+=.+$/.test(str) ? str.replace(/^--.+=/, '') : null);\n  const isCommand = (str: string) => schema.some(command => command.command === str);\n  const isCommandAlias = (str: string) => schema.some(command => command.aliases && command.aliases.includes(str));\n  const commandAliasToCommand = (alias: string) => schema.filter(s => s.aliases && s.aliases.includes(alias))[0].command;\n\n  const isOptionAlias = (command: string, str: string) => {\n    const cmd = schema.filter(c => c.command === command)[0];\n    if (!cmd || !cmd.options) return false;\n    return cmd.options.some(option => option.aliases && option.aliases.includes(str));\n  };\n\n  const optionAliasToOption = (command: string, alias: string) => {\n    const cmd = schema.filter(c => c.command === command)[0];\n    if (!cmd || !cmd.options) return undefined;\n\n    const matchingOption = cmd.options.find(option => option.aliases && option.aliases.includes(alias));\n    if (matchingOption) return matchingOption.name;\n\n    return undefined;\n  };\n\n  const isNumber = (num: unknown): num is number => typeof num === 'number' && !Number.isNaN(num) && Number.isFinite(num);\n\n  /** Get the key without the value E.g. `--output-text=\"text\"` => `outputText` */\n  const parseKey = (str: string) => {\n    const match = str.toLowerCase().match(/^--?[a-z]+(?:-[a-z]+)*/);\n    if (!match || !match[0]) return null;\n    return match[0].replace(/^--?/, '').replace(/-\\w/gi, t => t.substring(1).toUpperCase());\n  };\n\n  const results: { command?: string; args: string[]; [key: string]: unknown } = { args: [] };\n  const syntax: ('command' | 'option' | 'arg')[] = [];\n\n  for (const str of process.argv.slice(2)) {\n    const key = parseKey(str),\n      boolean = toBoolean(str),\n      number = toNumber(str),\n      string = isNumber(number) ? null : toString(str),\n      command = isCommand(str) ? str : null,\n      commandAlias = isCommandAlias(str) ? str : null,\n      arg = !str.startsWith('-') ? str : null,\n      value = number ?? boolean ?? string ?? command ?? arg;\n\n    // * options\n    if (key !== null) {\n      if (results.command && isOptionAlias(results.command, key)) {\n        const option = optionAliasToOption(results.command, key);\n        if (option) results[option] = value;\n        syntax.push('option');\n        continue;\n      }\n\n      results[key] = value;\n      syntax.push('option');\n\n      continue;\n    }\n\n    // * args\n    if (arg && !command && !commandAlias) {\n      results.args.push(arg);\n      syntax.push('arg');\n      continue;\n    }\n\n    // * command\n    if (command || commandAlias) {\n      const parsedCommand = command || commandAliasToCommand(commandAlias!);\n      results.command = parsedCommand;\n      syntax.push('command');\n      continue;\n    }\n  }\n\n  return { results, syntax };\n}\n\nexport let printHelp = () => {\n  Log.warn('Help is not implemented yet');\n};\n\nexport function parse<T extends CommandSchema[]>(...params: T): ParseReturnType<T>;\nexport function parse<T extends CommandSchema[], const O extends ParseOptions<A>, const A extends ZodArray>(\n  ...params: [...T, O]\n  // @ts-expect-error undefined in globalOptions\n): ParseReturnType<[...T, { command: undefined; argsType: O['argsType']; options: O['globalOptions'] }]>;\nexport function parse<T extends CommandSchema[]>(...params: T): ParseReturnType<T> {\n  const options = ('globalOptions' in params[params.length - 1] ? params.pop() : {}) as ParseOptions;\n  const commands = params as T;\n\n  if (options.globalOptions) {\n    commands.unshift({\n      command: NO_COMMAND,\n      argsType: options.argsType,\n      options: options.globalOptions,\n    });\n  }\n\n  // validate schema and throw error if it fails\n  if (options.validateSchema ?? CONSTANTS.isDev) {\n    try {\n      validateDevInput(commands);\n    } catch (error) {\n      Log.error(error as string);\n      process.exit(1);\n    }\n  }\n\n  const zodUnion = schemaIntoZodUnion(commands);\n  const { results, syntax } = parseArguments(commands);\n\n  const HelpSchema = commandsSchemaToHelpSchema(commands, options.cliName, options.description, options.usage);\n  printHelp = () => printHelpFromSchema(HelpSchema);\n\n  const refined = zodUnion.superRefine((_, ctx) => {\n    // The first argument is not a command\n    if (syntax.includes('command') && syntax[0] !== 'command') {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'Syntax Error: Command must be the first argument. Move the command before other arguments.',\n        fatal: true,\n      });\n      return z.NEVER;\n    }\n\n    // Has more than one command\n    if (syntax.filter(t => t === 'command').length > 1) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'Syntax Error: Only one command is allowed. Remove extra commands.',\n        fatal: true,\n      });\n      return z.NEVER;\n    }\n  });\n\n  return refined.safeParse(results);\n}\n\nexport function createParseOptions<const T extends ParseOptions<A>, A extends ZodArray>(options: T & ParseOptions<A>): T {\n  return options;\n}\n\nexport function formatError(error: z.ZodError) {\n  const err = error.format();\n\n  for (const key in err) {\n    const el = err[key as keyof typeof err] as { _errors: string[] } | string[];\n    if (!el) continue;\n\n    if (Array.isArray(el) && el.length) {\n      Log.error(el.join('\\n'), '\\n');\n      continue;\n    }\n\n    if (key === 'args' && 'args' in err && typeof err.args === 'object') {\n      for (const argKye in err.args) {\n        const argEl = err.args[argKye as keyof typeof err.args] as { _errors: string[] };\n\n        if (!argEl) continue;\n\n        if (argKye === '_errors' && '_errors' in argEl && argEl._errors.length) {\n          Log.error('args :', argEl._errors.join('\\n'), '\\n');\n        }\n\n        if ('_errors' in argEl && argEl._errors.length) Log.error(key, ':', argEl._errors.join('\\n'), '\\n');\n      }\n    }\n\n    if ('_errors' in el && el._errors.length) Log.error(key, ':', el._errors.join('\\n'), '\\n');\n  }\n}\n", "import chalk from 'chalk';\nimport { NO_COMMAND } from './parseSchema.js';\n\nimport type { AllowedOptionTypes, CommandSchema } from './types.js';\n\nexport function commandsSchemaToHelpSchema(schema: CommandSchema[], cliName?: string, cliDescription?: string, usage?: string) {\n  const getType = (item: AllowedOptionTypes) => {\n    // literal\n    if ('value' in item) return 'literal';\n    // string\n    if (item.safeParse('string').success) return 'string';\n    // number\n    if (item.safeParse(1).success) return 'number';\n    // boolean\n    if (item.safeParse(true).success) return 'boolean';\n\n    return 'string';\n  };\n\n  const getCliName = (name: string) => {\n    if (name.length === 1) return '-' + name;\n    return '--' + name.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n  };\n\n  const getSyntax = (name: string, item: AllowedOptionTypes) => {\n    const type = getType(item);\n    const cliName = getCliName(name);\n    if (cliName.length === 2) return cliName; // on character E.g. -e\n    if (type === 'boolean' || type === 'number') return `${cliName}=${type}`;\n    if (type === 'string') return `${cliName}=\"${type}\"`;\n    if (type === 'literal' && 'value' in item) {\n      if (typeof item.value === 'number') return `${cliName}=${item.value.toString()}`;\n      return `${cliName}=\"${item.value}\"`;\n    }\n\n    return cliName;\n  };\n\n  const global = schema.filter(c => c.command === NO_COMMAND)[0];\n  return {\n    name: cliName ?? 'node-cli',\n    description: cliDescription,\n    usage,\n    global: {\n      argsDescription: global?.argsType?.description,\n      options:\n        global?.options?.map(o => ({\n          syntax: getSyntax(o.name, o.type),\n          isOptional: o.type.isOptional(),\n          description: o.type.description,\n          aliases: o.aliases && o.aliases.map(a => getCliName(a)),\n        })) ?? [],\n    },\n    commands: schema\n      .filter(c => c.command !== NO_COMMAND)\n      .map(c => ({\n        name: c.command,\n        description: c.description,\n        argsDescription: c.argsType && c.argsType.description,\n        aliases: c.aliases,\n        options:\n          c.options &&\n          c.options.map(o => ({\n            syntax: getSyntax(o.name, o.type),\n            isOptional: o.type.isOptional(),\n            description: o.type.description,\n            aliases: o.aliases && o.aliases.map(a => getCliName(a)),\n          })),\n      })),\n  };\n}\n\nexport function printHelpFromSchema(schema: ReturnType<typeof commandsSchemaToHelpSchema>) {\n  const c = {\n    title: chalk.bold.blue.inverse,\n    aliasesTitle: chalk.hex('#E91E63'),\n    command: chalk.bold.yellow,\n    options: chalk.cyan,\n    args: chalk.green,\n    alias: chalk.hex('#00BCD4'),\n    description: chalk.white,\n    value: chalk.magenta,\n    optional: chalk.italic.dim,\n    dim: chalk.white.dim,\n  };\n\n  const formatSyntax = (syntax: string) => {\n    if (syntax.includes('=')) {\n      const [part1, part2] = syntax.split('=');\n      return c.options(part1) + chalk.reset('=') + c.value(part2.replace(/\"/g, c.dim('\"')));\n    }\n    return c.options(syntax);\n  };\n\n  /** New line */\n  const nl = (count: number) => '\\n'.repeat(count);\n  /** Space */\n  const indent = (count: number) => ' '.repeat(count);\n\n  const longestCommandName = Math.max(...schema.commands.map(command => command.name?.length ?? 0));\n  const longestGlobalSyntax = Math.max(...schema.global.options.map(option => option?.syntax?.length ?? 0));\n  const longestSyntax = Math.max(\n    ...schema.commands.map(command =>\n      command.options ? Math.max(...command.options.map(option => option.syntax?.length ?? 0), 0) : 0,\n    ),\n  );\n  const longest = Math.max(longestCommandName, longestGlobalSyntax, longestSyntax);\n\n  // * CLI Description\n  if (schema.description) {\n    console.log(c.title(' Description '), nl(1));\n    console.log(indent(2), c.dim('-'), c.description(schema.description), nl(1));\n  }\n\n  // * CLI Usage\n  const usage = schema.usage ?? schema.name + c.command(' <command>') + c.options(' [options]') + c.args(' [args]');\n  console.log(c.title(' Usage '), nl(1));\n  console.log(indent(2), c.dim('$'), usage, nl(1));\n\n  // * Commands\n  if (schema.commands.length) {\n    console.log(c.title(' Commands '));\n\n    for (let i = 0; i < schema.commands.length; i++) {\n      const { name, description, aliases, argsDescription, options } = schema.commands[i];\n      if (!name) continue;\n\n      // Command\n      console.log(\n        nl(1),\n        c.dim('#'),\n        c.command(name),\n        description ? indent(longest + 6 - name.length) + c.dim('\u2022 ') + description : '',\n      );\n\n      // Command Aliases\n      if (aliases) {\n        console.log(indent(longest + 9), c.aliasesTitle('Aliases  '), c.alias(aliases.join(c.dim(', '))));\n      }\n\n      // Command Arguments Description\n      if (argsDescription) {\n        console.log(indent(longest + 9), c.args('Arguments'), c.dim('\u2022'), c.description(argsDescription));\n      }\n\n      if (!options) continue;\n\n      // Command Options\n      for (let o = 0; o < options.length; o++) {\n        const { syntax, isOptional, description, aliases } = options[o];\n        console.log(\n          nl(1),\n          indent(2),\n          formatSyntax(syntax),\n          indent(longest + 4 - syntax.length),\n          c.optional(isOptional ? 'optional ' : 'required '),\n          description ? c.dim('\u2022 ') + description : '',\n        );\n\n        // Options Aliases\n        if (aliases) {\n          console.log(indent(longest + 9), c.aliasesTitle('Aliases  '), c.alias(aliases.join(c.dim(', '))));\n        }\n      }\n    }\n  }\n\n  console.log('');\n\n  const globalOptions = schema.global.options;\n\n  if (globalOptions.length === 0) return;\n\n  // * Global\n  console.log(c.title(' Global '));\n\n  // Global Arguments Description\n  if (schema.global.argsDescription) {\n    console.log(nl(1), indent(2), c.args.bold('Arguments:'), indent(longest - 6), c.dim('\u2022'), schema.global.argsDescription);\n  }\n\n  // Global Options\n  for (let i = 0; i < globalOptions.length; i++) {\n    const { syntax, isOptional, description, aliases } = globalOptions[i];\n\n    console.log(\n      nl(1),\n      indent(2),\n      formatSyntax(syntax),\n      indent(longest + 4 - syntax.length),\n      c.optional(isOptional ? 'optional ' : 'required '),\n      description ? c.dim('\u2022 ') + description : '',\n    );\n\n    // Options Aliases\n    if (aliases) {\n      console.log(indent(longest + 9), c.aliasesTitle('Aliases  '), c.alias(aliases.join(c.dim(', '))));\n    }\n  }\n\n  console.log('');\n}\n", "import type { z } from 'zod';\nimport type { CommandSchema } from './types.js';\n\nfunction checkForDuplicates(arr: (string | undefined)[]) {\n  const uniqueSet = new Set<string>();\n\n  for (const item of arr) {\n    if (!item) continue;\n    if (uniqueSet.has(item)) return item;\n    uniqueSet.add(item);\n  }\n\n  return null;\n}\n\n/**\n * - Validate the command schema and throw an error if any of the checks fail.\n * - This function is used to validate the command schema before it is used in the CLI.\n */\nexport function validateDevInput(schema: CommandSchema[]) {\n  const testCommandRe = /^[a-z]+-?[a-z]+$/i;\n  const testCommandStr = (arr: (string | undefined)[]) => arr.findIndex(c => c && !testCommandRe.test(c));\n\n  const testOptionRe = /^(?:[a-z]+(?:[A-Z][a-z]*)*|[a-z])$/;\n  const testOptionStr = (arr: string[]) => arr.findIndex(c => !testOptionRe.test(c));\n\n  const isTypeBoolean = (t: z.ZodTypeAny) => t.safeParse(true).success;\n\n  // Check for duplicate commands\n  const commands = schema.map(s => s.command);\n  const duplicatedCommand = checkForDuplicates(commands);\n  if (duplicatedCommand) throw new Error(`Duplicate command: ${duplicatedCommand}`);\n\n  // Validate command string format\n  const failedCommandIndex = testCommandStr(commands);\n  if (failedCommandIndex !== -1) {\n    throw new Error(`Invalid command string format: \"${commands[failedCommandIndex]}\"`);\n  }\n\n  // Check for duplicate command aliases\n  const commandAliases = schema.filter(s => s.aliases).flatMap(s => s.aliases!);\n  const duplicatedCommandAlias = checkForDuplicates(commandAliases);\n  if (duplicatedCommandAlias) throw new Error(`Duplicate command alias: ${duplicatedCommandAlias}`);\n\n  // Validate command alias string format\n  const failedCommandAliasIndex = testCommandStr(commandAliases);\n  if (failedCommandAliasIndex !== -1) {\n    throw new Error(`Invalid command alias string format: \"${commandAliases[failedCommandAliasIndex]}\"`);\n  }\n\n  // Check for duplicate command and aliases\n  const duplicatedCommandAndAlias = checkForDuplicates([...commands, ...commandAliases]);\n  if (duplicatedCommandAndAlias) throw new Error(`Duplicate command and alias: \"${duplicatedCommandAndAlias}\"`);\n\n  for (let i = 0; i < schema.length; i++) {\n    const { options } = schema[i];\n    if (!options) continue;\n\n    // Check for duplicate option names in the same command\n    const optionsNames = options.map(o => o.name);\n    const duplicatedOption = checkForDuplicates(optionsNames);\n    if (duplicatedOption) throw new Error(`Duplicate option: \"${duplicatedOption}\"`);\n\n    // Validate option string format\n    const failedOptionIndex = testOptionStr(optionsNames);\n    if (failedOptionIndex !== -1) throw new Error(`Invalid option string format: \"${optionsNames[failedOptionIndex]}\"`);\n\n    // Check for duplicate option aliases in the same command\n    const optionAliases = options.filter(o => o.aliases).flatMap(o => o.aliases!);\n    const duplicatedOptionAlias = checkForDuplicates(optionAliases);\n    if (duplicatedOptionAlias) {\n      throw new Error(`Duplicate option alias: \"${duplicatedOptionAlias}\"`);\n    }\n\n    // Validate option alias string format\n    const failedOptionAliasIndex = testOptionStr(optionAliases);\n    if (failedOptionAliasIndex !== -1) {\n      throw new Error(`Invalid option alias string format: \"${optionAliases[failedOptionAliasIndex]}\"`);\n    }\n\n    // Ensure option name and alias lengths are longer than 1 character for non-boolean types\n    for (let o = 0; o < options.length; o++) {\n      const { name, type, aliases } = options[o];\n      const isBoolean = isTypeBoolean(type);\n\n      if (name.length === 1 && !isBoolean) {\n        throw new Error(`Option name must be longer than 1 character for a non-boolean type: \"${name}\"`);\n      }\n\n      if (!aliases) continue;\n\n      aliases.forEach(a => {\n        if (a.length === 1 && !isBoolean) {\n          throw new Error(`Option alias must be longer than 1 character for a non-boolean type: \"${name}\"`);\n        }\n      });\n    }\n  }\n}\n", "import { createCommandSchema } from './commandSchema.js';\nimport { createParseOptions, parse, printHelp, formatError } from './parseSchema.js';\n\nconst Schema = {\n  /**\n   * - Create a command schema, that can be used in the parse function\n   * - `Schema.parse(schema, ...schema, options)`\n   *\n   * @example\n   *   const schema = Schema.createCommand({\n   *     command: 'example', // required\n   *     description: 'Example command', // Optional - for generating the help message\n   *     aliases: ['example-alias'], // Optional - will trigger the same command in the CLI\n   *     // Optional - for validating user input and type safety\n   *     options: [\n   *       {\n   *         // Note: one character option names are limited to `boolean` types only\n   *         // Required - should be used like this in the CLI `--option-name=\"value\"`\n   *         name: 'OptionName',\n   *         // Required - Zod types, add description for generating the help message\n   *         type: z.string().optional().describe('Option description'),\n   *         aliases: ['optionAlias'], // Optional - will trigger the same option in the CLI\n   *       },\n   *     ],\n   *   });\n   */\n  createCommand: createCommandSchema,\n  /**\n   * - Create options schema, that can be used in the parse function\n   * - `Schema.parse(schema, ...schema, options)`\n   * - You can also inline the options, if you want to\n   *\n   * @example\n   *   const options = Schema.createOptions({\n   *     // Optional - The CLI name that starts your CLI (package.json.name), for generating the help message\n   *     cliName: 'node-cli',\n   *     // Optional - The CLI description, for generating the help message\n   *     description: 'A CLI for testing.',\n   *     // Optional - Throw an error if the schema is invalid.\n   *     // This is recommended to set to false in production.\n   *     // **Default**: true if in development mode\n   *     validateSchema: true,\n   *     // Optional - Global options are used when no command is specified,\n   *     // For example: `node-cli --help`\n   *     globalOptions: [\n   *       {\n   *         name: 'help',\n   *         type: z.boolean().optional().describe('Show this help message.'),\n   *         aliases: ['h'],\n   *       },\n   *       {\n   *         name: 'version',\n   *         type: z.boolean().optional().describe('Show the version.'),\n   *         aliases: ['v'],\n   *       },\n   *     ],\n   *   });\n   */\n  createOptions: createParseOptions,\n  /**\n   * - Parse the arguments and return the results\n   * - `Schema.parse(schema, ...schema, options)`\n   *\n   * @example\n   *   const results = Schema.parse(schema, ...schema, options);\n   *   if(results.success) {\n   *   const { command } = results.data;\n   *   // check which command was called\n   *   if(command === 'example') {\n   *   const { OptionName } = results.data; // get the options related to the command\n   *   // do something\n   *   }\n   */\n  parse,\n  /**\n   * - Print the help message that was generated when calling `Schema.parse(schema, ...schema, options)`\n   * - If the help message is not generated, it will print a warning.\n   */\n  printHelp: () => printHelp(),\n\n  /** - Takes a Zod error object and prints a formatted error message. */\n  formatError,\n};\n\nexport default Schema;\n", "import inquirer from 'inquirer';\n\nexport async function askForName() {\n  type Answers = { name: string };\n\n  // \u2754 Ask for user input.\n  const { name } = await inquirer.prompt<Answers>([\n    {\n      type: 'input',\n      name: 'name',\n      default: 'John Doe',\n      message: 'Enter your name :',\n    },\n  ]);\n\n  return name;\n}\n\nexport async function askForAge() {\n  type Answers = { age: number };\n\n  // \u2754 Ask for user input.\n  const { age } = await inquirer.prompt<Answers>([\n    {\n      type: 'input',\n      name: 'age',\n      message: 'Enter your age :',\n    },\n  ]);\n\n  return age;\n}\n", "import { Log } from '@cli/logger.js';\r\nimport { spinner } from '@cli/spinner.js';\r\nimport { sleep } from '@cli/terminal.js';\r\nimport Schema from '@schema';\r\nimport { askForAge, askForName } from '@utils/utils.js';\r\nimport { z } from 'zod';\r\n\r\nexport default async function testCommand(name: string | undefined, age: number | undefined) {\r\n  name = name || (await askForName());\r\n  age = age || (await askForAge());\r\n\r\n  const loading = spinner('Processing...');\r\n  await sleep(2000);\r\n  loading.success('Processing done!');\r\n\r\n  Log.info(`Hello ${name}, you are ${age} years old.`);\r\n}\r\n\r\ntestCommand.schema = Schema.createCommand({\r\n  /**\r\n   * - **Required** `string`\r\n   * - The command name, use kebab-case.\r\n   * - Make sure to not duplicate commands and aliases.\r\n   *\r\n   * @example\r\n   *   command: 'run-app',\r\n   */\r\n  command: 'test',\r\n  /**\r\n   * - **Optional** `string`\r\n   * - The description of the command.\r\n   * - Used for generating the help message.\r\n   */\r\n  description: 'Run a command for testing.',\r\n  /**\r\n   * - **Optional** `string[]`\r\n   * - The aliases of the command.\r\n   * - Any of the aliases will trigger the same command in the CLI.\r\n   * - Make sure to not duplicate aliases and commands.\r\n   */\r\n  aliases: ['run-test', 'test-command'],\r\n  /**\r\n   * - **Optional** `z.ZodArray`\r\n   * - **Default** `z.string().array()`\r\n   * - The arguments of the command.\r\n   * - Those arguments are specific to this command.\r\n   * - Use `z.string().array().describe('Description')` to add a description for help message.\r\n   *\r\n   * @example\r\n   *   argsType: z.string().array().nonempty(), // None-empty string array.\r\n   *   argsType: z.coerce.number().array().max(1), // Converts string to number and accept one or no arguments.\r\n   */\r\n  argsType: z.string().array().describe('You can pass any arguments to this command.'),\r\n  /**\r\n   * - **Optional** `CommandOptions[]`\r\n   * - The options of the command.\r\n   * - Those options are specific to this command.\r\n   */\r\n  options: [\r\n    {\r\n      /**\r\n       * - **Required** `string`\r\n       * - The name of the option, use CamelCase.\r\n       * - For example: the syntax for the option `rootPath` is `--root-path=\"path\"`.\r\n       * - For boolean options, the syntax is `--option` or `--option=true`.\r\n       * - One character option names are limited to `boolean` types only E.g. `b` will be used for `-b`\r\n       *\r\n       * @example\r\n       *   name: 'help'; // Transforms to `--help`\r\n       *   name: 'rootPath'; // Transforms to `--root-path`\r\n       */\r\n      name: 'age',\r\n      /**\r\n       * - **Required** `ZodTypes` only string, number or boolean\r\n       * - The type of the option.\r\n       * - The will be used to validate the user input.\r\n       * - `Z.describe()` will be used to generate the help message.\r\n       *\r\n       * @example\r\n       *   type: z.boolean().optional().describe('Describe the option'),\r\n       *   type: z.string().describe('Describe the option'),\r\n       *\r\n       * @see https://zod.dev/?id=types\r\n       */\r\n      type: z.number().optional().describe('Your age in years.'),\r\n      /**\r\n       * - **Optional** `string[]`\r\n       * - The aliases of the option.\r\n       * - Any of the aliases will trigger the same option in the CLI.\r\n       * - One character option names are limited to `boolean` types\r\n       * - Make sure to not duplicate aliases.\r\n       */\r\n      aliases: ['yourAge'],\r\n    },\r\n    {\r\n      name: 'name',\r\n      type: z\r\n        .string({ invalid_type_error: 'must be a string E.g. --name=\"John\"' }) // type string with a custom error\r\n        .optional()\r\n        .describe('Your name.'),\r\n      aliases: ['yourName'],\r\n    },\r\n  ],\r\n});\r\n", "#!/usr/bin/env node\r\n\r\nimport { Log } from '@cli/logger.js';\r\nimport { CONSTANTS, testCliArgsInput } from '@cli/terminal.js';\r\nimport testCommand from '@commands/test-command.js';\r\nimport Schema from '@schema';\r\nimport gradient from 'gradient-string';\r\nimport { z } from 'zod';\r\nimport { ytsRss } from './sites/yts.js';\r\n\r\n// ? \uD83D\uDC47 title text gradient colors. for more colors see: `https://cssgradient.io/gradient-backgrounds`\r\nconst coolGradient = gradient([\r\n  { color: '#FA8BFF', pos: 0 },\r\n  { color: '#2BD2FF', pos: 0.5 },\r\n  { color: '#2BFF88', pos: 1 },\r\n]);\r\n\r\n// ? `https://www.kammerl.de/ascii/AsciiSignature.php` \uD83D\uDC48 to convert your app's title to ASCII art.\r\n// ? `https://codebeautify.org/javascript-escape-unescape` \uD83D\uDC48 escape your title's string for JavaScript.\r\nconsole.log(\r\n  coolGradient(String.raw` \r\n __   __     ______     _____     ______       __     ______        ______     __         __   \r\n/\\ \"-.\\ \\   /\\  __ \\   /\\  __-.  /\\  ___\\     /\\ \\   /\\  ___\\      /\\  ___\\   /\\ \\       /\\ \\  \r\n\\ \\ \\-.  \\  \\ \\ \\/\\ \\  \\ \\ \\/\\ \\ \\ \\  __\\    _\\_\\ \\  \\ \\___  \\     \\ \\ \\____  \\ \\ \\____  \\ \\ \\ \r\n \\ \\_\\\\\"\\_\\  \\ \\_____\\  \\ \\____-  \\ \\_____\\ /\\_____\\  \\/\\_____\\     \\ \\_____\\  \\ \\_____\\  \\ \\_\\\r\n  \\/_/ \\/_/   \\/_____/   \\/____/   \\/_____/ \\/_____/   \\/_____/      \\/_____/   \\/_____/   \\/_/\r\n                                                                                               \r\n`),\r\n);\r\n\r\n// \u26A0\uFE0F For testing in development mode only\r\nif (CONSTANTS.isDev) {\r\n  // Here you can test your CLI arguments while using hot reload in development mode.\r\n  testCliArgsInput('test --name=\"John Doe\" --age=\"30\" arg1 arg2 arg3');\r\n}\r\n\r\nasync function main() {\r\n  const options = Schema.createOptions({\r\n    /** The CLI name that starts your CLI, used for help command. */\r\n    cliName: 'node-cli',\r\n    /** CLI description, used for help command. */\r\n    description: 'A CLI for testing.',\r\n    /**\r\n     * - **Optional** `boolean`\r\n     * - **Default**: `true` when in development mode.\r\n     * - Throw an error if the schema is invalid.\r\n     * - Validate the schema, it's recommended to set this to `false` in production.\r\n     */\r\n    validateSchema: CONSTANTS.isDev,\r\n    /**\r\n     * **Optional** `string`\r\n     *\r\n     * - CLI usage syntax, used for help command.\r\n     */\r\n    argsType: z.string().array().length(0).describe('No arguments are required or allowed.'),\r\n    /**\r\n     * **Optional** `CommandOptions[]`\r\n     *\r\n     * - CLI global options, when no command is given, Example: `--version`\r\n     */\r\n    globalOptions: [\r\n      {\r\n        name: 'help',\r\n        type: z.boolean().optional().describe('Show this help message.'),\r\n        aliases: ['h'],\r\n      },\r\n      {\r\n        name: 'version',\r\n        type: z.boolean().optional().describe('Show the version.'),\r\n        aliases: ['v'],\r\n      },\r\n    ],\r\n  });\r\n\r\n  // Add all commands schemas here \uD83D\uDC47\r\n  const results = Schema.parse(testCommand.schema /** , You can add more */, options);\r\n\r\n  // when parsing arguments fails\r\n  if (!results.success) {\r\n    // ? See Zod docs for more information: `https://zod.dev/?id=error-handling`\r\n\r\n    // \uD83D\uDDA8\uFE0F print a formate error message\r\n    Schema.formatError(results.error);\r\n\r\n    // \uD83D\uDDA8\uFE0F print help message on error\r\n    Schema.printHelp();\r\n\r\n    process.exit(1);\r\n  }\r\n\r\n  const { command } = results.data;\r\n\r\n  if (!command) {\r\n    const { version } = results.data;\r\n\r\n    if (version) {\r\n      Log.info('\\n  version: 1.0.0\\n');\r\n      return;\r\n    }\r\n\r\n    Schema.printHelp();\r\n    return;\r\n  }\r\n\r\n  if (command === 'test') {\r\n    const { age, name, args } = results.data;\r\n\r\n    await testCommand(name, age);\r\n\r\n    if (args.length) Log.warn('\\nYou Passed extra arguments: ', args.join(', '));\r\n  }\r\n}\r\n\r\n// main(); // \uD83D\uDE80 Start the app.\r\n// rssParser()\r\n// fitGirlMagnets()\r\nytsRss()", "import Parser from \"rss-parser\";\n\n//parse the Rss feed from yts.am\n\nexport async function ytsRss() {\n  const parser = new Parser();\n  const ytsRegex = {\n    imdbRatingRegex: /([0-9].[0-9]\\/10)|(10|[0-9]\\/10)$/gm,\n    sizeRegex: /([0-9]?[0-9]?[0-9].[0-9]?[0-9]\\s?(GB|MB))|([0-9]?[0-9]\\s?(GB|MB))/gm,\n    durationRegex: /([0-9]hr\\s?[0-5]?[0-9]\\s?min)/gm,\n    descriptionRegex: /[0-9]\\s?min\\n?(.*)/gm,\n    genreRegex: /Genre:\\s?(\\w*\\s?\\/\\s?\\w*)/gm,\n    imageLinkRegex: /https:\\/\\/img.yts.mx\\/assets\\/images\\/\\w*\\/.*?\\/[^\"]+\"/gm,\n  };\n\n  const movies = [];\n  try {\n    const feed = await parser.parseURL(\"https://yts.am/rss\");\n    const items = feed.items;\n\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      const imdbRating = execRegex(\n        ytsRegex.imdbRatingRegex,\n        item.content ?? \"\",\n        1\n      );\n      const size = execRegex(ytsRegex.sizeRegex, item.content ?? \"\", 1);\n      const duration = execRegex(ytsRegex.durationRegex, item.content ?? \"\", 1);\n      const description = execRegex(\n        ytsRegex.descriptionRegex,\n        item.content ?? \"\",\n        1\n      ).replace(`<br /><br />`,'')\n      const genre = execRegex(ytsRegex.genreRegex, item.content ?? \"\", 1);\n      const imageLink = execRegex(\n        ytsRegex.imageLinkRegex,\n        item.content ?? \"\",\n        0\n      ).replace(`\"`,'')\n      const title = item.title;\n      const link = item.link;\n      movies.push({\n        imdbRating,\n        size,\n        duration,\n        description,\n        genre,\n        imageLink,\n        title,\n        link,\n      });\n    }\n    console.log(movies, \"ytsRss\");\n  } catch (error) {\n    console.log(error, \"ytsRss\");\n  }\n}\n\nfunction execRegex(regex: RegExp, value: string, index: number) {\n  const valueRegex = new RegExp(regex);\n  const challenge = valueRegex.exec(value);\n  if (challenge === null || challenge[index] === `<br /><br />`) return \"Not Found\";\n  return challenge[index];\n}\n"],
  "mappings": ";;;AAAA,OAAO,WAA+B;AAW/B,SAAS,OAAO,UAAqB;AAC1C,UAAQ,IAAI,eAAe,OAAO,OAAO,GAAG,GAAG,QAAQ;AACzD;AAEA,IAAI,OAAO,IAAI,aAAuB;AACpC,QAAM,EAAE,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvD,UAAQ,IAAI,WAAW,eAAe,WAAW,QAAQ,GAAG,MAAM,OAAO,YAAY,CAAC;AACxF;AAEA,IAAI,UAAU,IAAI,aAAuB;AACvC,QAAM,EAAE,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvD,UAAQ,IAAI,WAAW,eAAe,WAAW,OAAO,GAAG,MAAM,MAAM,YAAY,CAAC;AACtF;AAEA,IAAI,QAAQ,IAAI,aAAuB;AACrC,QAAM,EAAE,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvD,UAAQ,IAAI,WAAW,eAAe,SAAS,KAAK,GAAG,MAAM,IAAI,YAAY,CAAC;AAChF;AAEA,IAAI,OAAO,IAAI,aAAuB;AACpC,QAAM,EAAE,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvD,UAAQ,IAAI,WAAW,eAAe,QAAQ,MAAM,GAAG,MAAM,KAAK,YAAY,CAAC;AACjF;AAEA,SAAS,eAAe,OAAe,OAAkB;AACvD,UAAQ,IAAI,OAAO,CAAC,IAAI,MAAM,OAAO,EAAE;AACvC,SAAO,MAAM,KAAK,EAAE,GAAG,IAAI,MAAM,KAAK,EAAE,KAAK,QAAQ,KAAK,IAAI,MAAM,KAAK,EAAE,GAAG;AAChF;AAEA,SAAS,YAAY,UAAoB;AACvC,QAAM,UAAU,SAAS,KAAK,GAAG;AACjC,QAAM,eAAe;AACrB,QAAM,QAAQ,QAAQ,MAAM,YAAY;AAExC,MAAI,OAAO;AACT,UAAM,WAAW,MAAM,CAAC;AACxB,UAAM,eAAe,QAAQ,UAAU,MAAM,CAAC,EAAE,MAAM;AACtD,WAAO,EAAE,UAAU,aAAa;AAAA,EAClC;AAEA,SAAO,EAAE,UAAU,IAAI,cAAc,QAAQ;AAC/C;;;ACnDA,SAAS,oBAAoB;AAC7B,OAAO,UAAU;AAsDV,SAAS,MAAM,IAAY;AAChC,SAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AACvD;AAiBO,SAAS,iBAAiB,OAAe;AAC9C,QAAM,QAAQ;AACd,QAAM,SAAS,MACZ,MAAM,KAAK,EACX,IAAI,UAAQ,KAAK,QAAQ,MAAM,EAAE,CAAC,EAClC,OAAO,OAAO;AACjB,UAAQ,KAAK,KAAK,GAAG,MAAM;AAC7B;AAEO,IAAM,YAAY;AAAA;AAAA,EAEvB,UAAU,QAAQ;AAAA,EAClB,WAAW,QAAQ,aAAa;AAAA,EAChC,OAAO,QAAQ,aAAa;AAAA,EAC5B,SAAS,QAAQ,aAAa;AAAA;AAAA,EAE9B,OAAO;AAAA;AAAA,EAEP,IAAI,cAAc;AAChB,UAAM,aAAa,aAAa,QAAQ,KAAK,CAAC,CAAC;AAC/C,UAAM,mBAAmB,CAAC,eAAe,MAAM;AAC/C,UAAM,UAAU,IAAI,OAAO,IAAI,iBAAiB,KAAK,GAAG,CAAC,IAAI;AAC7D,WAAO,KAAK,QAAQ,UAAU,EAAE,QAAQ,SAAS,EAAE;AAAA,EACrD;AACF;;;ACjGA,OAAOA,YAAW;AAGlB,IAAM,SAAS,CAAC,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,QAAG;AAYzD,SAAS,QAAQ,SAAiB,gBAAgB,GAAG;AAC1D,MAAI,WACF;AAEF,iBAAe,MAAM,eAAe,SAAS,QAAQ,eAAe;AAClE,QAAI;AAAI,oBAAc,EAAE;AACxB,YAAQ,MAAM,YAAY,MAAM;AAChC,YAAQ,MAAM,WAAW,IAAI;AAE7B,YAAQ,MAAM,KAAK,YAAY,MAAM;AACnC,YAAM,MAAM,QAAQ,MAAM,KAAK,GAC7B,MAAM,KAAK,UAAU,GAAG,GACxB,KAAK,UAAU,KAAK,GAAG,IAAI,CAAC,EAAE,QAAQ,UAAU,EAAE,EAAE,MAAM,GAAG,GAC7D,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,MAAM,EAAE,KAAK,CAAC,KAAK,KAAK;AAE3D,cAAQ,MAAM,WAAW,KAAK;AAE9B,kBAAY,IAAI,QAAQ,KAAK,IAAI;AACjC,WAAK;AAEL,UAAI,IAAI;AACR,WAAK,YAAY,MAAM;AACrB,gBAAQ,OAAO,SAAS,GAAG,SAAS;AACpC,gBAAQ,OAAO,UAAU,CAAC;AAC1B,cAAMC,WAAUD,OAAM,KAAK,OAAO,MAAM,OAAO,MAAM,CAAC;AACtD,cAAM,iBAAiBA,OAAM,OAAO,YAAY;AAChD,gBAAQ,OAAO,MAAM,GAAGC,QAAO,KAAK,cAAc,EAAE;AAAA,MACtD,GAAG,EAAE;AAAA,IACP,CAAC;AAED,YAAQ,MAAM,OAAO;AACrB,YAAQ,OAAO,MAAM,SAAW;AAGhC,QAAI,OAAO;AACT,YAAM,MAAM,KAAK;AACjB,WAAK;AAAA,IACP;AAAA,EACF;AAEA,WAAS,OAAO;AACd,QAAI,CAAC;AAAI;AACT,kBAAc,EAAE;AAChB,SAAK;AACL,YAAQ,OAAO,SAAS,GAAG,SAAS;AACpC,YAAQ,OAAO,UAAU,CAAC;AAAA,EAC5B;AAEA,QAAM;AAGN,SAAO;AAAA;AAAA,IAEL;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA,QAAQ,YAAoB;AAC1B,WAAK;AACL,UAAI,QAAQ,YAAY,IAAI;AAAA,IAC9B;AAAA;AAAA,IAEA,MAAM,YAAoB;AACxB,WAAK;AACL,UAAI,MAAM,YAAY,IAAI;AAAA,IAC5B;AAAA;AAAA,IAEA,IAAI,YAAoB;AACtB,WAAK;AACL,cAAQ,OAAO,MAAM,UAAU;AAAA,IACjC;AAAA,EACF;AACF;;;ACzFA,SAAS,KAAAC,UAAS;;;ACAlB,SAAS,SAAS;;;ACAlB,OAAOC,YAAW;AAKX,SAAS,2BAA2B,QAAyB,SAAkB,gBAAyB,OAAgB;AAC7H,QAAM,UAAU,CAAC,SAA6B;AAE5C,QAAI,WAAW;AAAM,aAAO;AAE5B,QAAI,KAAK,UAAU,QAAQ,EAAE;AAAS,aAAO;AAE7C,QAAI,KAAK,UAAU,CAAC,EAAE;AAAS,aAAO;AAEtC,QAAI,KAAK,UAAU,IAAI,EAAE;AAAS,aAAO;AAEzC,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,CAAC,SAAiB;AACnC,QAAI,KAAK,WAAW;AAAG,aAAO,MAAM;AACpC,WAAO,OAAO,KAAK,QAAQ,UAAU,WAAS,IAAI,MAAM,YAAY,CAAC,EAAE;AAAA,EACzE;AAEA,QAAM,YAAY,CAAC,MAAc,SAA6B;AAC5D,UAAM,OAAO,QAAQ,IAAI;AACzB,UAAMC,WAAU,WAAW,IAAI;AAC/B,QAAIA,SAAQ,WAAW;AAAG,aAAOA;AACjC,QAAI,SAAS,aAAa,SAAS;AAAU,aAAO,GAAGA,QAAO,IAAI,IAAI;AACtE,QAAI,SAAS;AAAU,aAAO,GAAGA,QAAO,KAAK,IAAI;AACjD,QAAI,SAAS,aAAa,WAAW,MAAM;AACzC,UAAI,OAAO,KAAK,UAAU;AAAU,eAAO,GAAGA,QAAO,IAAI,KAAK,MAAM,SAAS,CAAC;AAC9E,aAAO,GAAGA,QAAO,KAAK,KAAK,KAAK;AAAA,IAClC;AAEA,WAAOA;AAAA,EACT;AAEA,QAAM,SAAS,OAAO,OAAO,OAAK,EAAE,YAAY,UAAU,EAAE,CAAC;AAC7D,SAAO;AAAA,IACL,MAAM,WAAW;AAAA,IACjB,aAAa;AAAA,IACb;AAAA,IACA,QAAQ;AAAA,MACN,iBAAiB,QAAQ,UAAU;AAAA,MACnC,SACE,QAAQ,SAAS,IAAI,QAAM;AAAA,QACzB,QAAQ,UAAU,EAAE,MAAM,EAAE,IAAI;AAAA,QAChC,YAAY,EAAE,KAAK,WAAW;AAAA,QAC9B,aAAa,EAAE,KAAK;AAAA,QACpB,SAAS,EAAE,WAAW,EAAE,QAAQ,IAAI,OAAK,WAAW,CAAC,CAAC;AAAA,MACxD,EAAE,KAAK,CAAC;AAAA,IACZ;AAAA,IACA,UAAU,OACP,OAAO,OAAK,EAAE,YAAY,UAAU,EACpC,IAAI,QAAM;AAAA,MACT,MAAM,EAAE;AAAA,MACR,aAAa,EAAE;AAAA,MACf,iBAAiB,EAAE,YAAY,EAAE,SAAS;AAAA,MAC1C,SAAS,EAAE;AAAA,MACX,SACE,EAAE,WACF,EAAE,QAAQ,IAAI,QAAM;AAAA,QAClB,QAAQ,UAAU,EAAE,MAAM,EAAE,IAAI;AAAA,QAChC,YAAY,EAAE,KAAK,WAAW;AAAA,QAC9B,aAAa,EAAE,KAAK;AAAA,QACpB,SAAS,EAAE,WAAW,EAAE,QAAQ,IAAI,OAAK,WAAW,CAAC,CAAC;AAAA,MACxD,EAAE;AAAA,IACN,EAAE;AAAA,EACN;AACF;AAEO,SAAS,oBAAoB,QAAuD;AACzF,QAAM,IAAI;AAAA,IACR,OAAOC,OAAM,KAAK,KAAK;AAAA,IACvB,cAAcA,OAAM,IAAI,SAAS;AAAA,IACjC,SAASA,OAAM,KAAK;AAAA,IACpB,SAASA,OAAM;AAAA,IACf,MAAMA,OAAM;AAAA,IACZ,OAAOA,OAAM,IAAI,SAAS;AAAA,IAC1B,aAAaA,OAAM;AAAA,IACnB,OAAOA,OAAM;AAAA,IACb,UAAUA,OAAM,OAAO;AAAA,IACvB,KAAKA,OAAM,MAAM;AAAA,EACnB;AAEA,QAAM,eAAe,CAAC,WAAmB;AACvC,QAAI,OAAO,SAAS,GAAG,GAAG;AACxB,YAAM,CAAC,OAAO,KAAK,IAAI,OAAO,MAAM,GAAG;AACvC,aAAO,EAAE,QAAQ,KAAK,IAAIA,OAAM,MAAM,GAAG,IAAI,EAAE,MAAM,MAAM,QAAQ,MAAM,EAAE,IAAI,GAAG,CAAC,CAAC;AAAA,IACtF;AACA,WAAO,EAAE,QAAQ,MAAM;AAAA,EACzB;AAGA,QAAM,KAAK,CAAC,UAAkB,KAAK,OAAO,KAAK;AAE/C,QAAM,SAAS,CAAC,UAAkB,IAAI,OAAO,KAAK;AAElD,QAAM,qBAAqB,KAAK,IAAI,GAAG,OAAO,SAAS,IAAI,aAAW,QAAQ,MAAM,UAAU,CAAC,CAAC;AAChG,QAAM,sBAAsB,KAAK,IAAI,GAAG,OAAO,OAAO,QAAQ,IAAI,YAAU,QAAQ,QAAQ,UAAU,CAAC,CAAC;AACxG,QAAM,gBAAgB,KAAK;AAAA,IACzB,GAAG,OAAO,SAAS;AAAA,MAAI,aACrB,QAAQ,UAAU,KAAK,IAAI,GAAG,QAAQ,QAAQ,IAAI,YAAU,OAAO,QAAQ,UAAU,CAAC,GAAG,CAAC,IAAI;AAAA,IAChG;AAAA,EACF;AACA,QAAM,UAAU,KAAK,IAAI,oBAAoB,qBAAqB,aAAa;AAG/E,MAAI,OAAO,aAAa;AACtB,YAAQ,IAAI,EAAE,MAAM,eAAe,GAAG,GAAG,CAAC,CAAC;AAC3C,YAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,YAAY,OAAO,WAAW,GAAG,GAAG,CAAC,CAAC;AAAA,EAC7E;AAGA,QAAM,QAAQ,OAAO,SAAS,OAAO,OAAO,EAAE,QAAQ,YAAY,IAAI,EAAE,QAAQ,YAAY,IAAI,EAAE,KAAK,SAAS;AAChH,UAAQ,IAAI,EAAE,MAAM,SAAS,GAAG,GAAG,CAAC,CAAC;AACrC,UAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,IAAI,GAAG,GAAG,OAAO,GAAG,CAAC,CAAC;AAG/C,MAAI,OAAO,SAAS,QAAQ;AAC1B,YAAQ,IAAI,EAAE,MAAM,YAAY,CAAC;AAEjC,aAAS,IAAI,GAAG,IAAI,OAAO,SAAS,QAAQ,KAAK;AAC/C,YAAM,EAAE,MAAM,aAAa,SAAS,iBAAiB,QAAQ,IAAI,OAAO,SAAS,CAAC;AAClF,UAAI,CAAC;AAAM;AAGX,cAAQ;AAAA,QACN,GAAG,CAAC;AAAA,QACJ,EAAE,IAAI,GAAG;AAAA,QACT,EAAE,QAAQ,IAAI;AAAA,QACd,cAAc,OAAO,UAAU,IAAI,KAAK,MAAM,IAAI,EAAE,IAAI,SAAI,IAAI,cAAc;AAAA,MAChF;AAGA,UAAI,SAAS;AACX,gBAAQ,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE,aAAa,WAAW,GAAG,EAAE,MAAM,QAAQ,KAAK,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;AAAA,MAClG;AAGA,UAAI,iBAAiB;AACnB,gBAAQ,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE,KAAK,WAAW,GAAG,EAAE,IAAI,QAAG,GAAG,EAAE,YAAY,eAAe,CAAC;AAAA,MAClG;AAEA,UAAI,CAAC;AAAS;AAGd,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,cAAM,EAAE,QAAQ,YAAY,aAAAC,cAAa,SAAAC,SAAQ,IAAI,QAAQ,CAAC;AAC9D,gBAAQ;AAAA,UACN,GAAG,CAAC;AAAA,UACJ,OAAO,CAAC;AAAA,UACR,aAAa,MAAM;AAAA,UACnB,OAAO,UAAU,IAAI,OAAO,MAAM;AAAA,UAClC,EAAE,SAAS,aAAa,cAAc,WAAW;AAAA,UACjDD,eAAc,EAAE,IAAI,SAAI,IAAIA,eAAc;AAAA,QAC5C;AAGA,YAAIC,UAAS;AACX,kBAAQ,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE,aAAa,WAAW,GAAG,EAAE,MAAMA,SAAQ,KAAK,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;AAAA,QAClG;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,UAAQ,IAAI,EAAE;AAEd,QAAM,gBAAgB,OAAO,OAAO;AAEpC,MAAI,cAAc,WAAW;AAAG;AAGhC,UAAQ,IAAI,EAAE,MAAM,UAAU,CAAC;AAG/B,MAAI,OAAO,OAAO,iBAAiB;AACjC,YAAQ,IAAI,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE,KAAK,KAAK,YAAY,GAAG,OAAO,UAAU,CAAC,GAAG,EAAE,IAAI,QAAG,GAAG,OAAO,OAAO,eAAe;AAAA,EACzH;AAGA,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,UAAM,EAAE,QAAQ,YAAY,aAAa,QAAQ,IAAI,cAAc,CAAC;AAEpE,YAAQ;AAAA,MACN,GAAG,CAAC;AAAA,MACJ,OAAO,CAAC;AAAA,MACR,aAAa,MAAM;AAAA,MACnB,OAAO,UAAU,IAAI,OAAO,MAAM;AAAA,MAClC,EAAE,SAAS,aAAa,cAAc,WAAW;AAAA,MACjD,cAAc,EAAE,IAAI,SAAI,IAAI,cAAc;AAAA,IAC5C;AAGA,QAAI,SAAS;AACX,cAAQ,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE,aAAa,WAAW,GAAG,EAAE,MAAM,QAAQ,KAAK,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;AAAA,IAClG;AAAA,EACF;AAEA,UAAQ,IAAI,EAAE;AAChB;;;ACtMA,SAAS,mBAAmB,KAA6B;AACvD,QAAM,YAAY,oBAAI,IAAY;AAElC,aAAW,QAAQ,KAAK;AACtB,QAAI,CAAC;AAAM;AACX,QAAI,UAAU,IAAI,IAAI;AAAG,aAAO;AAChC,cAAU,IAAI,IAAI;AAAA,EACpB;AAEA,SAAO;AACT;AAMO,SAAS,iBAAiB,QAAyB;AACxD,QAAM,gBAAgB;AACtB,QAAM,iBAAiB,CAAC,QAAgC,IAAI,UAAU,OAAK,KAAK,CAAC,cAAc,KAAK,CAAC,CAAC;AAEtG,QAAM,eAAe;AACrB,QAAM,gBAAgB,CAAC,QAAkB,IAAI,UAAU,OAAK,CAAC,aAAa,KAAK,CAAC,CAAC;AAEjF,QAAM,gBAAgB,CAAC,MAAoB,EAAE,UAAU,IAAI,EAAE;AAG7D,QAAM,WAAW,OAAO,IAAI,OAAK,EAAE,OAAO;AAC1C,QAAM,oBAAoB,mBAAmB,QAAQ;AACrD,MAAI;AAAmB,UAAM,IAAI,MAAM,sBAAsB,iBAAiB,EAAE;AAGhF,QAAM,qBAAqB,eAAe,QAAQ;AAClD,MAAI,uBAAuB,IAAI;AAC7B,UAAM,IAAI,MAAM,mCAAmC,SAAS,kBAAkB,CAAC,GAAG;AAAA,EACpF;AAGA,QAAM,iBAAiB,OAAO,OAAO,OAAK,EAAE,OAAO,EAAE,QAAQ,OAAK,EAAE,OAAQ;AAC5E,QAAM,yBAAyB,mBAAmB,cAAc;AAChE,MAAI;AAAwB,UAAM,IAAI,MAAM,4BAA4B,sBAAsB,EAAE;AAGhG,QAAM,0BAA0B,eAAe,cAAc;AAC7D,MAAI,4BAA4B,IAAI;AAClC,UAAM,IAAI,MAAM,yCAAyC,eAAe,uBAAuB,CAAC,GAAG;AAAA,EACrG;AAGA,QAAM,4BAA4B,mBAAmB,CAAC,GAAG,UAAU,GAAG,cAAc,CAAC;AACrF,MAAI;AAA2B,UAAM,IAAI,MAAM,iCAAiC,yBAAyB,GAAG;AAE5G,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,EAAE,QAAQ,IAAI,OAAO,CAAC;AAC5B,QAAI,CAAC;AAAS;AAGd,UAAM,eAAe,QAAQ,IAAI,OAAK,EAAE,IAAI;AAC5C,UAAM,mBAAmB,mBAAmB,YAAY;AACxD,QAAI;AAAkB,YAAM,IAAI,MAAM,sBAAsB,gBAAgB,GAAG;AAG/E,UAAM,oBAAoB,cAAc,YAAY;AACpD,QAAI,sBAAsB;AAAI,YAAM,IAAI,MAAM,kCAAkC,aAAa,iBAAiB,CAAC,GAAG;AAGlH,UAAM,gBAAgB,QAAQ,OAAO,OAAK,EAAE,OAAO,EAAE,QAAQ,OAAK,EAAE,OAAQ;AAC5E,UAAM,wBAAwB,mBAAmB,aAAa;AAC9D,QAAI,uBAAuB;AACzB,YAAM,IAAI,MAAM,4BAA4B,qBAAqB,GAAG;AAAA,IACtE;AAGA,UAAM,yBAAyB,cAAc,aAAa;AAC1D,QAAI,2BAA2B,IAAI;AACjC,YAAM,IAAI,MAAM,wCAAwC,cAAc,sBAAsB,CAAC,GAAG;AAAA,IAClG;AAGA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,EAAE,MAAM,MAAM,QAAQ,IAAI,QAAQ,CAAC;AACzC,YAAM,YAAY,cAAc,IAAI;AAEpC,UAAI,KAAK,WAAW,KAAK,CAAC,WAAW;AACnC,cAAM,IAAI,MAAM,wEAAwE,IAAI,GAAG;AAAA,MACjG;AAEA,UAAI,CAAC;AAAS;AAEd,cAAQ,QAAQ,OAAK;AACnB,YAAI,EAAE,WAAW,KAAK,CAAC,WAAW;AAChC,gBAAM,IAAI,MAAM,yEAAyE,IAAI,GAAG;AAAA,QAClG;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;AFxFO,IAAM,aAAa;AAE1B,SAAS,eAAe,QAAyB;AAC/C,QAAM,YAAY,CAAC,QAAiB,kBAAkB,KAAK,GAAG,IAAI,QAAQ,kBAAkB,KAAK,GAAG,IAAI,OAAO;AAC/G,QAAM,WAAW,CAAC,QAAiB,yBAAyB,KAAK,GAAG,IAAI,CAAC,IAAI,QAAQ,UAAU,EAAE,IAAI;AACrG,QAAM,WAAW,CAAC,QAAiB,YAAY,KAAK,GAAG,IAAI,IAAI,QAAQ,UAAU,EAAE,IAAI;AACvF,QAAM,YAAY,CAAC,QAAgB,OAAO,KAAK,aAAW,QAAQ,YAAY,GAAG;AACjF,QAAM,iBAAiB,CAAC,QAAgB,OAAO,KAAK,aAAW,QAAQ,WAAW,QAAQ,QAAQ,SAAS,GAAG,CAAC;AAC/G,QAAM,wBAAwB,CAAC,UAAkB,OAAO,OAAO,OAAK,EAAE,WAAW,EAAE,QAAQ,SAAS,KAAK,CAAC,EAAE,CAAC,EAAE;AAE/G,QAAM,gBAAgB,CAAC,SAAiB,QAAgB;AACtD,UAAM,MAAM,OAAO,OAAO,OAAK,EAAE,YAAY,OAAO,EAAE,CAAC;AACvD,QAAI,CAAC,OAAO,CAAC,IAAI;AAAS,aAAO;AACjC,WAAO,IAAI,QAAQ,KAAK,YAAU,OAAO,WAAW,OAAO,QAAQ,SAAS,GAAG,CAAC;AAAA,EAClF;AAEA,QAAM,sBAAsB,CAAC,SAAiB,UAAkB;AAC9D,UAAM,MAAM,OAAO,OAAO,OAAK,EAAE,YAAY,OAAO,EAAE,CAAC;AACvD,QAAI,CAAC,OAAO,CAAC,IAAI;AAAS,aAAO;AAEjC,UAAM,iBAAiB,IAAI,QAAQ,KAAK,YAAU,OAAO,WAAW,OAAO,QAAQ,SAAS,KAAK,CAAC;AAClG,QAAI;AAAgB,aAAO,eAAe;AAE1C,WAAO;AAAA,EACT;AAEA,QAAM,WAAW,CAAC,QAAgC,OAAO,QAAQ,YAAY,CAAC,OAAO,MAAM,GAAG,KAAK,OAAO,SAAS,GAAG;AAGtH,QAAM,WAAW,CAAC,QAAgB;AAChC,UAAM,QAAQ,IAAI,YAAY,EAAE,MAAM,wBAAwB;AAC9D,QAAI,CAAC,SAAS,CAAC,MAAM,CAAC;AAAG,aAAO;AAChC,WAAO,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,SAAS,OAAK,EAAE,UAAU,CAAC,EAAE,YAAY,CAAC;AAAA,EACxF;AAEA,QAAM,UAAwE,EAAE,MAAM,CAAC,EAAE;AACzF,QAAM,SAA2C,CAAC;AAElD,aAAW,OAAO,QAAQ,KAAK,MAAM,CAAC,GAAG;AACvC,UAAM,MAAM,SAAS,GAAG,GACtB,UAAU,UAAU,GAAG,GACvB,SAAS,SAAS,GAAG,GACrB,SAAS,SAAS,MAAM,IAAI,OAAO,SAAS,GAAG,GAC/C,UAAU,UAAU,GAAG,IAAI,MAAM,MACjC,eAAe,eAAe,GAAG,IAAI,MAAM,MAC3C,MAAM,CAAC,IAAI,WAAW,GAAG,IAAI,MAAM,MACnC,QAAQ,UAAU,WAAW,UAAU,WAAW;AAGpD,QAAI,QAAQ,MAAM;AAChB,UAAI,QAAQ,WAAW,cAAc,QAAQ,SAAS,GAAG,GAAG;AAC1D,cAAM,SAAS,oBAAoB,QAAQ,SAAS,GAAG;AACvD,YAAI;AAAQ,kBAAQ,MAAM,IAAI;AAC9B,eAAO,KAAK,QAAQ;AACpB;AAAA,MACF;AAEA,cAAQ,GAAG,IAAI;AACf,aAAO,KAAK,QAAQ;AAEpB;AAAA,IACF;AAGA,QAAI,OAAO,CAAC,WAAW,CAAC,cAAc;AACpC,cAAQ,KAAK,KAAK,GAAG;AACrB,aAAO,KAAK,KAAK;AACjB;AAAA,IACF;AAGA,QAAI,WAAW,cAAc;AAC3B,YAAM,gBAAgB,WAAW,sBAAsB,YAAa;AACpE,cAAQ,UAAU;AAClB,aAAO,KAAK,SAAS;AACrB;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,SAAS,OAAO;AAC3B;AAEO,IAAI,YAAY,MAAM;AAC3B,MAAI,KAAK,6BAA6B;AACxC;AAOO,SAAS,SAAoC,QAA+B;AACjF,QAAM,UAAW,mBAAmB,OAAO,OAAO,SAAS,CAAC,IAAI,OAAO,IAAI,IAAI,CAAC;AAChF,QAAM,WAAW;AAEjB,MAAI,QAAQ,eAAe;AACzB,aAAS,QAAQ;AAAA,MACf,SAAS;AAAA,MACT,UAAU,QAAQ;AAAA,MAClB,SAAS,QAAQ;AAAA,IACnB,CAAC;AAAA,EACH;AAGA,MAAI,QAAQ,kBAAkB,UAAU,OAAO;AAC7C,QAAI;AACF,uBAAiB,QAAQ;AAAA,IAC3B,SAAS,OAAO;AACd,UAAI,MAAM,KAAe;AACzB,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,WAAW,mBAAmB,QAAQ;AAC5C,QAAM,EAAE,SAAS,OAAO,IAAI,eAAe,QAAQ;AAEnD,QAAM,aAAa,2BAA2B,UAAU,QAAQ,SAAS,QAAQ,aAAa,QAAQ,KAAK;AAC3G,cAAY,MAAM,oBAAoB,UAAU;AAEhD,QAAM,UAAU,SAAS,YAAY,CAAC,GAAG,QAAQ;AAE/C,QAAI,OAAO,SAAS,SAAS,KAAK,OAAO,CAAC,MAAM,WAAW;AACzD,UAAI,SAAS;AAAA,QACX,MAAM,EAAE,aAAa;AAAA,QACrB,SAAS;AAAA,QACT,OAAO;AAAA,MACT,CAAC;AACD,aAAO,EAAE;AAAA,IACX;AAGA,QAAI,OAAO,OAAO,OAAK,MAAM,SAAS,EAAE,SAAS,GAAG;AAClD,UAAI,SAAS;AAAA,QACX,MAAM,EAAE,aAAa;AAAA,QACrB,SAAS;AAAA,QACT,OAAO;AAAA,MACT,CAAC;AACD,aAAO,EAAE;AAAA,IACX;AAAA,EACF,CAAC;AAED,SAAO,QAAQ,UAAU,OAAO;AAClC;AAEO,SAAS,mBAAwE,SAAiC;AACvH,SAAO;AACT;AAEO,SAAS,YAAY,OAAmB;AAC7C,QAAM,MAAM,MAAM,OAAO;AAEzB,aAAW,OAAO,KAAK;AACrB,UAAM,KAAK,IAAI,GAAuB;AACtC,QAAI,CAAC;AAAI;AAET,QAAI,MAAM,QAAQ,EAAE,KAAK,GAAG,QAAQ;AAClC,UAAI,MAAM,GAAG,KAAK,IAAI,GAAG,IAAI;AAC7B;AAAA,IACF;AAEA,QAAI,QAAQ,UAAU,UAAU,OAAO,OAAO,IAAI,SAAS,UAAU;AACnE,iBAAW,UAAU,IAAI,MAAM;AAC7B,cAAM,QAAQ,IAAI,KAAK,MAA+B;AAEtD,YAAI,CAAC;AAAO;AAEZ,YAAI,WAAW,aAAa,aAAa,SAAS,MAAM,QAAQ,QAAQ;AACtE,cAAI,MAAM,UAAU,MAAM,QAAQ,KAAK,IAAI,GAAG,IAAI;AAAA,QACpD;AAEA,YAAI,aAAa,SAAS,MAAM,QAAQ;AAAQ,cAAI,MAAM,KAAK,KAAK,MAAM,QAAQ,KAAK,IAAI,GAAG,IAAI;AAAA,MACpG;AAAA,IACF;AAEA,QAAI,aAAa,MAAM,GAAG,QAAQ;AAAQ,UAAI,MAAM,KAAK,KAAK,GAAG,QAAQ,KAAK,IAAI,GAAG,IAAI;AAAA,EAC3F;AACF;;;ADrLO,SAAS,oBAA0E,SAAkC;AAC1H,SAAO;AACT;AAEO,SAAS,mBAA8C,QAAW;AASvE,QAAM,UAAqB,CAAC;AAE5B,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,MAAM,OAAO,CAAC;AACpB,UAAM,UAA8C,CAAC;AAErD,QAAI,IAAI,SAAS;AACf,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,QAAQ,KAAK;AAC3C,cAAM,SAAS,IAAI,QAAQ,CAAC;AAC5B,gBAAQ,OAAO,IAAI,IAAI,OAAO;AAAA,MAChC;AAAA,IACF;AAGA,QAAI,IAAI,YAAY,YAAY;AAC9B,cAAQ,KAAKC,GAAE,OAAO,EAAE,SAASA,GAAE,QAAQ,MAAU,GAAG,MAAM,IAAI,YAAYA,GAAE,OAAO,EAAE,MAAM,GAAG,GAAG,QAAQ,CAAC,EAAE,OAAO,CAAC;AACxH;AAAA,IACF;AAEA,UAAM,UAAUA,GAAE,OAAO,EAAE,SAASA,GAAE,QAAQ,IAAI,OAAQ,GAAG,MAAM,IAAI,YAAYA,GAAE,OAAO,EAAE,MAAM,GAAG,GAAG,QAAQ,CAAC,EAAE,OAAO;AAC5H,YAAQ,KAAK,OAAO;AAAA,EACtB;AAEA,QAAM,eAAe;AAErB,SAAOA,GAAE,mBAAmB,WAAW,YAAY;AACrD;;;AIzCA,IAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBb,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgCf,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAef;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,MAAM,UAAU;AAAA;AAAA,EAG3B;AACF;AAEA,IAAO,wBAAQ;;;ACpFf,OAAO,cAAc;AAErB,eAAsB,aAAa;AAIjC,QAAM,EAAE,KAAK,IAAI,MAAM,SAAS,OAAgB;AAAA,IAC9C;AAAA,MACE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,SAAS;AAAA,IACX;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAEA,eAAsB,YAAY;AAIhC,QAAM,EAAE,IAAI,IAAI,MAAM,SAAS,OAAgB;AAAA,IAC7C;AAAA,MACE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;AC1BA,SAAS,KAAAC,UAAS;AAElB,eAAO,YAAmC,MAA0B,KAAyB;AAC3F,SAAO,QAAS,MAAM,WAAW;AACjC,QAAM,OAAQ,MAAM,UAAU;AAE9B,QAAM,UAAU,QAAQ,eAAe;AACvC,QAAM,MAAM,GAAI;AAChB,UAAQ,QAAQ,kBAAkB;AAElC,MAAI,KAAK,SAAS,IAAI,aAAa,GAAG,aAAa;AACrD;AAEA,YAAY,SAAS,sBAAO,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASxC,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMT,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,SAAS,CAAC,YAAY,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYpC,UAAUA,GAAE,OAAO,EAAE,MAAM,EAAE,SAAS,6CAA6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnF,SAAS;AAAA,IACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYE,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaN,MAAMA,GAAE,OAAO,EAAE,SAAS,EAAE,SAAS,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQzD,SAAS,CAAC,SAAS;AAAA,IACrB;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,MAAMA,GACH,OAAO,EAAE,oBAAoB,sCAAsC,CAAC,EACpE,SAAS,EACT,SAAS,YAAY;AAAA,MACxB,SAAS,CAAC,UAAU;AAAA,IACtB;AAAA,EACF;AACF,CAAC;;;ACjGD,OAAO,cAAc;AACrB,SAAS,KAAAC,UAAS;;;ACPlB,OAAO,YAAY;AAInB,eAAsB,SAAS;AAC7B,QAAM,SAAS,IAAI,OAAO;AAC1B,QAAM,WAAW;AAAA,IACf,iBAAiB;AAAA,IACjB,WAAW;AAAA,IACX,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,YAAY;AAAA,IACZ,gBAAgB;AAAA,EAClB;AAEA,QAAM,SAAS,CAAC;AAChB,MAAI;AACF,UAAM,OAAO,MAAM,OAAO,SAAS,oBAAoB;AACvD,UAAM,QAAQ,KAAK;AAEnB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,aAAa;AAAA,QACjB,SAAS;AAAA,QACT,KAAK,WAAW;AAAA,QAChB;AAAA,MACF;AACA,YAAM,OAAO,UAAU,SAAS,WAAW,KAAK,WAAW,IAAI,CAAC;AAChE,YAAM,WAAW,UAAU,SAAS,eAAe,KAAK,WAAW,IAAI,CAAC;AACxE,YAAM,cAAc;AAAA,QAClB,SAAS;AAAA,QACT,KAAK,WAAW;AAAA,QAChB;AAAA,MACF,EAAE,QAAQ,gBAAe,EAAE;AAC3B,YAAM,QAAQ,UAAU,SAAS,YAAY,KAAK,WAAW,IAAI,CAAC;AAClE,YAAM,YAAY;AAAA,QAChB,SAAS;AAAA,QACT,KAAK,WAAW;AAAA,QAChB;AAAA,MACF,EAAE,QAAQ,KAAI,EAAE;AAChB,YAAM,QAAQ,KAAK;AACnB,YAAM,OAAO,KAAK;AAClB,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AACA,YAAQ,IAAI,QAAQ,QAAQ;AAAA,EAC9B,SAAS,OAAO;AACd,YAAQ,IAAI,OAAO,QAAQ;AAAA,EAC7B;AACF;AAEA,SAAS,UAAU,OAAe,OAAe,OAAe;AAC9D,QAAM,aAAa,IAAI,OAAO,KAAK;AACnC,QAAM,YAAY,WAAW,KAAK,KAAK;AACvC,MAAI,cAAc,QAAQ,UAAU,KAAK,MAAM;AAAgB,WAAO;AACtE,SAAO,UAAU,KAAK;AACxB;;;ADrDA,IAAM,eAAe,SAAS;AAAA,EAC5B,EAAE,OAAO,WAAW,KAAK,EAAE;AAAA,EAC3B,EAAE,OAAO,WAAW,KAAK,IAAI;AAAA,EAC7B,EAAE,OAAO,WAAW,KAAK,EAAE;AAC7B,CAAC;AAID,QAAQ;AAAA,EACN,aAAa,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAOrB;AACD;AAGA,IAAI,UAAU,OAAO;AAEnB,mBAAiB,kDAAkD;AACrE;AAkFA,OAAO;",
  "names": ["chalk", "spinner", "z", "chalk", "cliName", "chalk", "description", "aliases", "z", "z", "z"]
}
